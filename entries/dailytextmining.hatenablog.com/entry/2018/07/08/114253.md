---
Title: 2018/7/7【15日目】辞書型に変換して並び替えを行う
Category:
- 180日間テキストマイニング
Date: 2018-07-08T11:42:53+09:00
URL: https://dailytextmining.hatenablog.com/entry/2018/07/08/114253
EditURL: https://blog.hatena.ne.jp/rimt/dailytextmining.hatenablog.com/atom/entry/10257846132599187733
---

昨日からの分析を続けていきます。
ちなみに昨日の段階での重要そうな単語ランキングトップ10はこちらです。
```
'co'
'https'
'express'
'お願い'
'今日'
'原宿'
'最後'
'brz'
'buenísimo'
'ch'
```

ひとまずデータ量を増やすために、SQLを叩きます。2018年6月7日から7月7日までの30日分のtweetデータを得られました。ちなみに、この期間内のデータ数は1411件でした。

##https://を取り除く前処理
昨日の段階で、'co’、’https’が段違いに重要になってしまっていますので、前処置としてhttps : //から始まってcoで終わるものは消しておきましょう。
正規表現で書くとこんな感じになるそうです。

```
(https?)(:\/\/[-_.!~*\'()a-zA-Z0-9;\/?:\@&=+\$,%#]+)
```
Pythonで正規表現を使う場合、re.sub関数を使うので、reをimportしておきます。

そして、MeCabで単語にバラす前に処理しておきます。コードはこんな感じになりました。

```python
import re

for content in os.listdir('test_dir'):
    with open('test_dir/' + content, 'r') as read_file, open('henkan/' + content, 'w') as write_file:
        for line in read_file:
            reline = re.sub('(https?)(:\/\/[-_.!~*\'()a-zA-Z0-9;\/?:\@&=+\$,%#]+)', '', line)
            tagger = MeCab.Tagger()
            tagger.parse('')
            node = tagger.parseToNode(reline)
            while node:
                if node.feature.startswith('名詞'):
                    write_file.write(node.surface + '\n')
                node = node.next
```

あと、気になりましたのが、出力をスコアが高い順に変更したいです。今のままですと、どう頑張っても並び替えをさせる方法が思いつかないので、単語とスコアを使って辞書型に変換したいとおもいます。
辞書型に変換するにはdic関数を使えばいいようです。ただ、今回の場合、まずはzip関数でリストをタプルに変換する必要があるようですので、まずはzip関数から実行します。Value側の数字はインクリメントで増やしていきます。

```
i += 0
dic = dict(zip(terms, X_train_tf[i].toarray()[0]))
print(dic)
```
実行結果
```
{'10': 0.0, '12': 0.0, '16': 0.0, '17': 0.0, '18': 0.0, '1994': 0.0, '20': 0.037796447300922721, '2018': 0.037796447300922721, '21': 0.0, '215': 0.037796447300922721, '22': 0.0, '23': 0.0, '26': 0.0, '30': 0.037796447300922721, '35': 0.0, '48': 0.0, '50': 0.0, '755': 0.0, 'akb': 0.0, 'akbingo': 0.0, 'akbshow': 0.0, 'ameba’:（中略）
```

あとはこれを並び替えすればいいのですが、辞書型の並び替えにはOrderedDictを使うとのこと。コードはほとんど公式のままです。このままだと0が最初にきてしまいますので、reverseを付けて大きい数字から並ぶようにします。

> list.sort() と sorted() の両方とも reverse パラメータを 真偽値として受け付けます。このパラメータは降順ソートを行うかどうかの フラグとして利用されます。 例えば、学生のデータを age の逆順で得たい場合:

```
from collections import OrderedDict
ranking = OrderedDict(sorted(d.items(), key=lambda x:x[1], reverse=True))
print(ranking)
```
実行結果
```
OrderedDict([('公演', 0.30237157840738177), ('ちゃん', 0.22677868380553634), ('今日', 0.22677868380553634), ('日本', 0.22677868380553634), ('さん', 0.18898223650461363), ('たくさん', 0.18898223650461363), ('サッカー', 0.18898223650461363), ('皆さん', 0.18898223650461363), 
```

これでランキング形式ができました。午後こそは分析を始めたいと思います。
